#include <stdio.h>
#include <stdlib.h>

#define WHITE 0
#define GRAY  1
#define BLACK 2

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    int V;
    Node** adj;   // adjacency list
    int* color;   // WHITE, GRAY, BLACK
    int* d;       // distance (BFS)
    int* f;       // finish time (DFS)
    int* pi;      // parent
} Graph;

// Queue for BFS
typedef struct {
    int items[100];
    int front, rear;
} Queue;

void initQueue(Queue* q) {
    q->front = q->rear = -1;
}

int isEmpty(Queue* q) {
    return q->front == -1;
}

void enqueue(Queue* q, int v) {
    if (q->rear == 99) return;
    if (q->front == -1) q->front = 0;
    q->items[++q->rear] = v;
}

int dequeue(Queue* q) {
    if (isEmpty(q)) return -1;
    int item = q->items[q->front];
    if (q->front == q->rear) q->front = q->rear = -1;
    else q->front++;
    return item;
}

// Create graph
Graph* createGraph(int V) {
    Graph* g = malloc(sizeof(Graph));
    g->V = V;
    g->adj = malloc(V * sizeof(Node*));
    g->color = malloc(V * sizeof(int));
    g->d = malloc(V * sizeof(int));
    g->f = malloc(V * sizeof(int));
    g->pi = malloc(V * sizeof(int));

    for (int i = 0; i < V; i++) {
        g->adj[i] = NULL;
        g->color[i] = WHITE;
        g->d[i] = -1;
        g->f[i] = -1;
        g->pi[i] = -1;
    }
    return g;
}

void addEdge(Graph* g, int u, int v) {
    Node* node = malloc(sizeof(Node));
    node->vertex = v;
    node->next = g->adj[u];
    g->adj[u] = node;
}

// BFS Algorithm
void BFS(Graph* g, int s) {
    for (int u = 0; u < g->V; u++) {
        if (u != s) {
            g->color[u] = WHITE;
            g->d[u] = -1;
            g->pi[u] = -1;
        }
    }

    g->color[s] = GRAY;
    g->d[s] = 0;
    g->pi[s] = -1;

    Queue q;
    initQueue(&q);
    enqueue(&q, s);

    while (!isEmpty(&q)) {
        int u = dequeue(&q);
        Node* temp = g->adj[u];
        while (temp) {
            int v = temp->vertex;
            if (g->color[v] == WHITE) {
                g->color[v] = GRAY;
                g->d[v] = g->d[u] + 1;
                g->pi[v] = u;
                enqueue(&q, v);
            }
            temp = temp->next;
        }
        g->color[u] = BLACK;
    }
}

// DFS Helper
int time = 0;

void DFSVisit(Graph* g, int u) {
    time++;
    g->d[u] = time;
    g->color[u] = GRAY;

    Node* temp = g->adj[u];
    while (temp) {
        int v = temp->vertex;
        if (g->color[v] == WHITE) {
            g->pi[v] = u;
            DFSVisit(g, v);
        }
        temp = temp->next;
    }

    g->color[u] = BLACK;
    time++;
    g->f[u] = time;
}

// DFS Algorithm
void DFS(Graph* g) {
    for (int u = 0; u < g->V; u++) {
        g->color[u] = WHITE;
        g->pi[u] = -1;
    }
    time = 0;
    for (int u = 0; u < g->V; u++) {
        if (g->color[u] == WHITE) {
            DFSVisit(g, u);
        }
    }
}

// Driver
int main() {
    int V = 6; // Example graph
    Graph* g = createGraph(V);

    addEdge(g, 0, 1);
    addEdge(g, 0, 2);
    addEdge(g, 1, 3);
    addEdge(g, 1, 4);
    addEdge(g, 2, 5);

    printf("BFS starting from vertex 0:\n");
    BFS(g, 0);
    for (int i = 0; i < V; i++) {
        printf("Vertex %d: distance = %d, parent = %d\n", i, g->d[i], g->pi[i]);
    }

    printf("\nDFS traversal:\n");
    DFS(g);
    for (int i = 0; i < V; i++) {
        printf("Vertex %d: discovery = %d, finish = %d, parent = %d\n",
               i, g->d[i], g->f[i], g->pi[i]);
    }

    return 0;
}
